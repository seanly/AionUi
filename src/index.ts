/**
 * @license
 * Copyright 2025 AionUi (aionui.com)
 * SPDX-License-Identifier: Apache-2.0
 */

import './utils/configureChromium';
import fs from 'fs';
import path from 'path';
import { app, BrowserWindow, screen } from 'electron';
import fixPath from 'fix-path';
import { initMainAdapterWithWindow } from './adapter/main';
import { ipcBridge } from './common';
import './process';
import { initializeAcpDetector } from './process/bridge';
import WorkerManage from './process/WorkerManage';
import { startWebServer } from './webserver';
import { SERVER_CONFIG } from './webserver/config/constants';
import { applyZoomToWindow } from './process/utils/zoom';
// @ts-expect-error - electron-squirrel-startup doesn't have types
import electronSquirrelStartup from 'electron-squirrel-startup';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// 修复 macOS 和 Linux 下 GUI 应用的 PATH 环境变量,使其与命令行一致
if (process.platform === 'darwin' || process.platform === 'linux') {
  fixPath();
}

// Handle Squirrel startup events (Windows installer)
if (electronSquirrelStartup) {
  app.quit();
}

// 主进程全局错误处理器
// Global error handlers for main process
// 捕获未处理的同步异常，防止显示 Electron 默认错误对话框
// Catch uncaught synchronous exceptions to prevent Electron's default error dialog
process.on('uncaughtException', (error) => {
  console.error('[Main Process] Uncaught Exception:', error);
  // 在生产环境中，可以将错误记录到文件或上报到错误追踪服务
  // In production, errors can be logged to file or sent to error tracking service
  if (process.env.NODE_ENV !== 'development') {
    console.error('[Main Process] Fatal error occurred, but continuing...');
  }
});

// 捕获未处理的 Promise 拒绝，避免应用崩溃
// Catch unhandled Promise rejections to prevent app crashes
process.on('unhandledRejection', (reason, promise) => {
  console.error('[Main Process] Unhandled Promise Rejection at:', promise, 'reason:', reason);
  // 可以在这里添加错误上报逻辑
  // Error reporting logic can be added here
});

const hasSwitch = (flag: string) => process.argv.includes(`--${flag}`) || app.commandLine.hasSwitch(flag);
const getSwitchValue = (flag: string): string | undefined => {
  const withEqualsPrefix = `--${flag}=`;
  const equalsArg = process.argv.find((arg) => arg.startsWith(withEqualsPrefix));
  if (equalsArg) {
    return equalsArg.slice(withEqualsPrefix.length);
  }

  const argIndex = process.argv.indexOf(`--${flag}`);
  if (argIndex !== -1) {
    const nextArg = process.argv[argIndex + 1];
    if (nextArg && !nextArg.startsWith('--')) {
      return nextArg;
    }
  }

  const cliValue = app.commandLine.getSwitchValue(flag);
  return cliValue || undefined;
};
const hasCommand = (cmd: string) => process.argv.includes(cmd);

const WEBUI_CONFIG_FILE = 'webui.config.json';

type WebUIUserConfig = {
  port?: number | string;
  allowRemote?: boolean;
};

const parsePortValue = (value: unknown, sourceLabel: string): number | null => {
  if (value === undefined || value === null || value === '') {
    return null;
  }

  const portNumber = typeof value === 'number' ? value : parseInt(String(value), 10);
  if (!Number.isFinite(portNumber) || portNumber < 1 || portNumber > 65535) {
    console.warn(`[config] Ignoring invalid port from ${sourceLabel}:`, value);
    return null;
  }
  return portNumber;
};

const loadUserWebUIConfig = (): { config: WebUIUserConfig; path: string | null; exists: boolean } => {
  try {
    const userDataPath = app.getPath('userData');
    const configPath = path.join(userDataPath, WEBUI_CONFIG_FILE);
    if (!fs.existsSync(configPath)) {
      return { config: {}, path: configPath, exists: false };
    }

    const raw = fs.readFileSync(configPath, 'utf-8');
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') {
      console.warn(`[config] ${configPath} must export an object.`);
      return { config: {}, path: configPath, exists: false };
    }
    return { config: parsed as WebUIUserConfig, path: configPath, exists: true };
  } catch (error) {
    console.warn('[config] Failed to load webui.config.json:', error);
    return { config: {}, path: null, exists: false };
  }
};

const resolveWebUIPort = (config: WebUIUserConfig): number => {
  const cliPort = parsePortValue(getSwitchValue('port') ?? getSwitchValue('webui-port'), 'CLI (--port)');
  if (cliPort) return cliPort;

  const envPort = parsePortValue(process.env.AIONUI_PORT ?? process.env.PORT, 'environment variable (AIONUI_PORT/PORT)');
  if (envPort) return envPort;

  const configPort = parsePortValue(config.port, 'webui.config.json');
  if (configPort) return configPort;

  return SERVER_CONFIG.DEFAULT_PORT;
};

const parseBooleanEnv = (value?: string): boolean | null => {
  if (!value) return null;
  const normalized = value.trim().toLowerCase();
  if (['1', 'true', 'yes', 'on'].includes(normalized)) return true;
  if (['0', 'false', 'no', 'off'].includes(normalized)) return false;
  return null;
};

const resolveRemoteAccess = (config: WebUIUserConfig): boolean => {
  const envRemote = parseBooleanEnv(process.env.AIONUI_ALLOW_REMOTE || process.env.AIONUI_REMOTE);
  const hostHint = process.env.AIONUI_HOST?.trim();
  const hostRequestsRemote = hostHint ? ['0.0.0.0', '::', '::0'].includes(hostHint) : false;
  const configRemote = config.allowRemote === true;

  return isRemoteMode || hostRequestsRemote || envRemote === true || configRemote;
};

const isWebUIMode = hasSwitch('webui');
const isRemoteMode = hasSwitch('remote');
const isResetPasswordMode = hasCommand('--resetpass');

let mainWindow: BrowserWindow;

const createWindow = (): void => {
  // Get primary display size
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;

  // Set window size to 80% (4/5) of screen size for better visibility on high-resolution displays
  const windowWidth = Math.floor(screenWidth * 0.8);
  const windowHeight = Math.floor(screenHeight * 0.8);

  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: windowWidth,
    height: windowHeight,
    autoHideMenuBar: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  initMainAdapterWithWindow(mainWindow);
  void applyZoomToWindow(mainWindow);

  // Configure Content Security Policy (CSP) to fix Electron security warning
  // 配置内容安全策略以修复 Electron 安全警告
  // Reason: Electron warns about missing or unsafe CSP, which protects against XSS attacks
  // 原因：Electron 会对缺失或不安全的 CSP 发出警告，CSP 可防止 XSS 攻击
  // Using onHeadersReceived ensures CSP is applied reliably via HTTP headers
  // 使用 onHeadersReceived 确保通过 HTTP 头可靠地应用 CSP
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          [
            // Default: only allow resources from same origin / 默认：仅允许同源资源
            "default-src 'self'",
            // Scripts: allow same-origin + inline scripts (required by React) / 脚本：允许同源和内联脚本（React 需要）
            // Note: 'unsafe-eval' is intentionally excluded for security / 注意：为安全起见特意排除 'unsafe-eval'
            "script-src 'self' 'unsafe-inline'",
            // Styles: allow same-origin + inline styles (required by dynamic theming) / 样式：允许同源和内联样式（动态主题需要）
            "style-src 'self' 'unsafe-inline'",
            // Images: allow same-origin, data URIs, local files, blobs, and HTTPS (required by preview features and custom backgrounds) / 图片：允许同源、data URI、本地文件、blob 和 HTTPS（预览功能和自定义背景需要）
            "img-src 'self' data: file: blob: https:",
            // Fonts: allow same-origin and data URIs / 字体：允许同源和 data URI
            "font-src 'self' data:",
            // Network connections: allow same-origin, WebSocket, and localhost (required by WebUI mode) / 网络连接：允许同源、WebSocket 和 localhost（WebUI 模式需要）
            "connect-src 'self' ws: wss: http://localhost:* https://localhost:* http://127.0.0.1:*",
            // Media: allow same-origin and blobs (required by preview features) / 媒体：允许同源和 blob（预览功能需要）
            "media-src 'self' blob:",
            // Objects: disallow plugins for security / 对象：为安全起见禁止插件
            "object-src 'none'",
            // Base URI: restrict <base> tag to same-origin only / 基础 URI：限制 <base> 标签仅使用同源
            "base-uri 'self'",
            // Forms: restrict form submission to same-origin / 表单：限制表单提交到同源
            "form-action 'self'",
            // Frame ancestors: prevent clickjacking by disallowing embedding / 框架祖先：禁止嵌入以防止点击劫持
            "frame-ancestors 'none'",
          ].join('; '),
        ],
      },
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch((error) => {
    console.error('Failed to load main window URL:', error);
  });

  // 只在开发环境自动打开 DevTools / Only auto-open DevTools in development
  // 使用 app.isPackaged 判断更可靠，打包后的应用不会自动打开 DevTools
  // Using app.isPackaged is more reliable, packaged apps won't auto-open DevTools
  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools();
  }
};

// Menu.setApplicationMenu(null);

ipcBridge.application.openDevTools.provider(() => {
  if (mainWindow) {
    mainWindow.webContents.openDevTools();
  }
  return Promise.resolve();
});

const handleAppReady = async (): Promise<void> => {
  if (isResetPasswordMode) {
    // Handle password reset without creating window
    try {
      // Get username argument, filtering out flags (--xxx)
      // 获取用户名参数，过滤掉标志（--xxx）
      const resetPasswordIndex = process.argv.indexOf('--resetpass');
      const argsAfterCommand = process.argv.slice(resetPasswordIndex + 1);
      const username = argsAfterCommand.find((arg) => !arg.startsWith('--')) || 'admin';

      // Import resetpass logic
      const { resetPasswordCLI } = await import('./utils/resetPasswordCLI');
      await resetPasswordCLI(username);

      app.quit();
    } catch (error) {
      console.error('Failed to reset password:', error);
      app.exit(1);
    }
  } else if (isWebUIMode) {
    const userConfigInfo = loadUserWebUIConfig();
    if (userConfigInfo.exists && userConfigInfo.path) {
      console.log(`[config] Loaded ${userConfigInfo.path}`);
    }
    const resolvedPort = resolveWebUIPort(userConfigInfo.config);
    const allowRemote = resolveRemoteAccess(userConfigInfo.config);
    await startWebServer(resolvedPort, allowRemote);
  } else {
    createWindow();
  }

  // 启动时初始化ACP检测器 (skip in --resetpass mode)
  if (!isResetPasswordMode) {
    await initializeAcpDetector();
  }
};

// Ensure we don't miss the ready event when running in CLI/WebUI mode
void app
  .whenReady()
  .then(handleAppReady)
  .catch((error) => {
    console.error('Failed to initialize main process:', error);
    app.quit();
  });

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  // In WebUI mode, don't quit when windows are closed since we're running a web server
  if (!isWebUIMode && process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (!isWebUIMode && app.isReady() && BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('before-quit', () => {
  // 在应用退出前清理工作进程
  WorkerManage.clear();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
